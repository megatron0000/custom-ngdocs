/*
 * grunt-ngdocs
 * https://github.com/m7r/grunt-ngdocs
 *
 * Copyright (c) 2013 m7r
 * Licensed under the MIT license.
 */

/*
 * Adição minha na linha ~106 ; ~125~; ~164
 */

var reader = require('../src/reader.js'),
    ngdoc = require('../src/ngdoc.js'),
    path = require('path'),
    vm = require('vm');

var repohosts = [{
    re: /https?:\/\/github.com\/([^\/]+\/[^\/]+)|git@github.com:(.*)/,
    reSuffix: /\.git.*$/,
    sourceLink: 'https://github.com/{{repo}}/blob/{{sha}}/{{file}}#L{{codeline}}',
    editLink: 'https://github.com/{{repo}}/edit/master/{{file}}'
}];

module.exports = function(grunt) {
    var _ = grunt.util._,
        unittest = {},
        templates = path.resolve(__dirname, '../src/templates');

    grunt.registerMultiTask('ngdocs', 'build documentation', function() {
        /**
         * Initialized values:
         *  - pkg (string content of user´s package.json)
         *  - start (initial time)
         *  - done (success indication function)
         *  - section (name specified by user on his Gruntfile - example: "privateApi")
         *  - options (specified by user, complemented by defaults declared here)
         *  - setup (NG_DOCS generated by processing of sections that came before this, if any.
         *            This object  .sections, .pages, .apis, __file, __options) 
         */
        var start = now(),
            pkg = getPackage(), // reads package.json from user´s Gruntfile folder
            // Grunt is normally sync. this "done" is a success indicator for async
            done = this.async(),
            /**
             * Gets options specified by user.
             * Provided object is default. Only used if user did not specify something
             */
            options = this.options({
                dest: 'docs/',
                startPage: '/api',
                scripts: ['angular.js'],
                styles: [],
                title: pkg.title || pkg.name || '',
                html5Mode: false,
                editExample: true,
                sourceLink: true,
                editLink: true,
                inlinePartials: false
            }),
            section = this.target === 'all' ? 'api' : this.target,
            setup;
        // console.log(this.target); would print "all"

        /**
         * Copy options "scripts", "styles", "image" (specified by user on Gruntfile)
         * to appropriate folders inside /dest (user side)
         */

        //Copy the scripts into their own folder in docs, unless they are remote or default angular.js
        var linked = /^((https?:)?\/\/|\.\.\/)/;
        var gruntScriptsFolder = 'grunt-scripts';
        var gruntStylesFolder = 'grunt-styles';

        // If the options.script is an array of arrays ( useful when working with variables, for example: ['<%= vendor_files %>','<%= app_files %>'] )
        // convert to a single array with _.flatten ( http://underscorejs.org/#flatten )
        options.scripts = _.flatten(options.scripts);
        options.scripts = _.map(options.scripts, function(file) {
            if (file === 'angular.js') {
                return 'js/angular.min.js';
            }

            if (linked.test(file)) {
                return file;
            }

            var filename = file.split('/').pop();
            //Use path.join here because we aren't sure if options.dest has / or not
            grunt.file.copy(file, path.join(options.dest, gruntScriptsFolder, filename));

            //Return the script path: doesn't have options.dest in it, it's relative
            //to the docs folder itself
            return gruntScriptsFolder + '/' + filename;
        });

        if (options.image && !linked.test(options.image)) {
            grunt.file.copy(options.image, path.join(options.dest, gruntStylesFolder, options.image));
            options.image = gruntStylesFolder + '/' + options.image;
        }

        options.styles = _.map(options.styles, function(file) {
            if (linked.test(file)) {
                return file;
            }
            var filename = file.split('/').pop();
            grunt.file.copy(file, path.join(options.dest, 'css', filename));
            return 'css/' + filename;
        });

        /**
         * Checks if any setup is present. If yes, builds upon it. If not, creates a fresh object
         * Whatever the case, the Array setup.pages will be only extended (with item whose .section will be this section)
         */
        setup = prepareSetup(section, options);

        grunt.log.writeln('Generating Documentation...');

        /**
         * Substitute options.sourceLink and options.editLink to
         * the functions they must be. This involves prepareLinks() and makeLinkFn().
         * Right now, works for github repositories only.
         * 
         * For greater integration (besides github), change global var "repohosts"
         * (beginning of this file)
         */
        prepareLinks(pkg, options);

        /**
         * Use the reader module (from src/reader.js) to process all
         * block comments in all files the user did input.
         * Instances of Doc (src/ngdoc.Doc) are progressively
         * pushed onto reader.docs
         */
        reader.docs = [];
        this.files.forEach(function(f) {
            options.isAPI = f.api || section == 'api';
            setup.sections[section] = f.title || 'API Documentation';
            setup.apis[section] = options.isAPI;
            f.src.filter(exists).forEach(function(filepath) {
                var content = grunt.file.read(filepath);
                reader.process(content, filepath, section, options);
            });
        });

        /**
         * Merge is explained in "src/ngdoc.merge".
         * In short, some instances of Doc should not be top-level
         * (like properties or methods). They are downgraded
         * to child elements of should-be top level elements 
         * (like controllers or services).
         * 
         * reader.docs is obviously updated in the process
         */
        ngdoc.merge(reader.docs);

        /**
         * I disabled my own code after finding out that "moduleName" property of various
         * Doc instances are only properly set when their html() method is called,
         * which happens shortly after this part of this file
         */
        // //////////////////////////////
        // // Array com todos os objetos documentados. Código meu. Aproveitei o merge acima para isso
        // var fs = require('fs');
        // var file = path.resolve(options.dest, 'custom-resources');
        // if (!fs.existsSync(file))
        //     fs.mkdirSync(file);
        // file = path.resolve(file, 'data');
        // if (!fs.existsSync(file))
        //     fs.mkdirSync(file);
        // fs.writeFileSync(path.resolve(file, 'docs.json'), JSON.stringify(reader.docs));
        // //////////////////////////////


        /**
         * Writes all partials to their destinations in dest/partials/section/blablabla.html
         */
        reader.docs.forEach(function(doc) {
            // this hack is here because on OSX angular.module and angular.Module map to the same file.
            var id = doc.id.replace('angular.Module', 'angular.IModule').replace(':', '.');

            var file = path.resolve(options.dest, 'partials', doc.section, id + '.html');
            grunt.file.write(file, doc.html());
        });

        /**
         * Only console.logs found issues among links contained in docs
         */
        ngdoc.checkBrokenLinks(reader.docs, setup.apis, options);

        /**
         * In case of multiple documentation sections, current setup.pages
         * has only before-processed sections. Here, new pages (from this section)
         * are incorporated
         */
        setup.pages = _.union(setup.pages, ngdoc.metadata(reader.docs));


        /**
         * My code (custom)
         * Recursively copy '../custom-resources' to user /dest
         */
        grunt.file.recurse(path.resolve(__dirname, '../', 'src', 'custom-resources'), function(absPath, rootDir, subDir, filename) {
            grunt.file.copy(absPath, path.resolve(options.dest, 'custom-resources', subDir || "./", filename));
        });
        // Write metadata object too (grunt.file.write(file, content))
        grunt.file.write(path.resolve(options.dest, 'custom-resources', 'data', 'metadata.json'), JSON.stringify(reader.docs, null, 2));


        /**
         * Don´t know what this is supposed to do
         */
        if (options.navTemplate) {
            options.navContent = grunt.template.process(grunt.file.read(options.navTemplate));
        } else {
            options.navContent = '';
        }

        writeSetup(setup);

        if (options.inlinePartials) {
            inlinePartials(path.resolve(options.dest, 'index.html'), path.resolve(options.dest, 'partials'));
        }


        grunt.log.writeln('DONE. Generated ' + reader.docs.length + ' pages in ' + (now() - start) + 'ms.');
        done();
    });

    /**
     * Read "package.json" from user side
     */
    function getPackage() {
        /**
         * get 'pkg' config from top level config
         * inside GI folder (or where task was issued)
         */
        var pkg = grunt.config('pkg');
        try {
            // Also relative to the folder where task was issued (GI folder)
            pkg = grunt.file.readJSON('package.json');
        } catch (e) {
            // console.log(e);
        }
        return pkg ||  {};
    }

    /**
     * Generates a method with signature (file, line, codeline), which 
     * produces a link to a code file (for "view source")
     * 
     * Returns said method
     */
    function makeLinkFn(tmpl, values) {
        if (!tmpl || tmpl === true) {
            return false;
        }
        if (/\{\{\s*sha\s*\}\}/.test(tmpl)) {
            var shell = require('shelljs');
            var sha = shell.exec('git rev-parse HEAD', {
                silent: true
            });
            values.sha = ('' + sha.output).slice(0, 7);
        }
        // Did not work before, because method signature was wrong. It is "_.template(string, options)"
        tmpl = _.template(tmpl, {
            'interpolate': /\{\{(.+?)\}\}/g
        });
        return function(file, line, codeline) {
            values.file = file;
            values.line = line;
            values.codeline = codeline;
            values.filepath = path.dirname(file);
            values.filename = path.basename(file);
            return tmpl(values);
        };
    }

    /**
     * Reads "package.json" from user, gets repository link 
     * and uses it to generate true functions for 
     * options.editLink and options.sourceLink.
     * 
     * Returns nothing
     */
    function prepareLinks(pkg, options) {
        var values = {
            version: pkg.version || 'master'
        };
        var url = (pkg.repository || {}).url;

        /**
         * Extracts username/repository from "package.json" and updates
         * options.sourceLink and options.editLink, from booleans to template
         * strings
         */
        if (url && options.sourceLink === true || options.sourceEdit === true) {
            repohosts.some(function(host) {
                var match = url.match(host.re);
                if (match) {
                    values.repo = match[1] || match[2];
                    if (host.reSuffix) {
                        values.repo = values.repo.replace(host.reSuffix, '');
                    }
                    if (host.sourceLink && options.sourceLink === true) {
                        options.sourceLink = host.sourceLink;
                    }
                    if (host.editLink && options.editLink === true) {
                        options.editLink = host.editLink;
                    }
                }
                return match;
            });
        }
        /**
         * Second update to options.sourceLink and options.editLink,
         * from template strings to proper functions
         */
        options.sourceLink = makeLinkFn(options.sourceLink, values);
        options.editLink = makeLinkFn(options.editLink, values);
    }

    unittest.prepareLinks = prepareLinks;

    /**
     * Tries to load docs-setup.js (it will exist if this is not the first or only section being processed).
     * If it does not exist, initialize a blank "setup" object.
     * 
     * Also copies everything under ./templates (here) to dest/ (user side) using helper copyTemplates()
     */
    function prepareSetup(section, options) {
        var setup, data, context = {},
            file = path.resolve(options.dest, 'js/docs-setup.js');
        // console.log(file); Prints absolute path of destination

        // Can exist from processing of sections that came before this one, if any
        if (exists(file)) {
            // read setup from file
            data = grunt.file.read(file);
            // Executes "data" in context "context". If error occurs, logs stack traces to file "file"
            vm.runInNewContext(data, context, file);
            // context.NG_DOCS is a list of pages, a list of scripts, list of sections
            setup = context.NG_DOCS;
            // keep only pages from other build tasks
            setup.pages = _.filter(setup.pages, function(p) {
                return p.section !== section;
            });
        } else {
            // build clean dest
            setup = {
                sections: {},
                pages: [],
                apis: {}
            };
            // See definition for explanation
            copyTemplates(options.dest);
        }
        setup.__file = file; //root:\path\path\userWorkspace\dest\js\docs-setup.js
        setup.__options = options; // options from grunt
        return setup;
    }

    /**
     * Create setup file based on what has just been processed (if this is the only section)
     * Or recreate it (updated, incorporated version) if this is not the only section
     */
    function writeSetup(setup) {
        var options = setup.__options,
            content, data = {
                scripts: options.scripts,
                styles: options.styles,
                sections: _.keys(setup.sections).join('|'),
                discussions: options.discussions,
                analytics: options.analytics,
                navContent: options.navContent,
                title: options.title,
                image: options.image,
                titleLink: options.titleLink,
                imageLink: options.imageLink,
                bestMatch: options.bestMatch,
                deferLoad: !!options.deferLoad
            },
            template = options.template ? options.template : path.resolve(templates, 'index.tmpl');

        /**
         * Below three commands create index.html
         */
        content = grunt.file.read(template);
        // This processing of "index.tmpl" is merely for a few touches on top (like my custom css, if I have defined it).
        // Is the code that produces index.html from slight modification of index.tmpl
        content = grunt.template.process(content, {
            data: data
        });
        grunt.file.write(path.resolve(options.dest, 'index.html'), content);

        /**
         * Create setup file (if this is the only section)
         * Or recreate it (updated, incorporated version) if this is not the only section
         */
        setup.html5Mode = options.html5Mode;
        setup.editExample = options.editExample;
        setup.startPage = options.startPage;
        setup.discussions = options.discussions;
        setup.scripts = _.map(options.scripts, function(url) {
            return path.basename(url);
        });
        grunt.file.write(setup.__file, 'NG_DOCS=' + JSON.stringify(setup, replacer, 2) + ';');
    }

    /**
     * Copies everything inside ./templates (here), except .js files,
     * to dest/ folder in the user´s side
     */
    function copyTemplates(dest) {
        grunt.file.expandMapping(['**/*', '!**/*.tmpl'], dest, {
            cwd: templates
        }).forEach(function(f) {
            // console.log(f);
            var src = f.src[0],
                dest = f.dest;
            if (grunt.file.isDir(src)) {
                grunt.file.mkdir(dest);
            } else {
                grunt.file.copy(src, dest);
            }
        });
    }

    function inlinePartials(indexFile, partialsFolder) {
        var indexFolder = path.dirname(indexFile);
        var partials = grunt.file.expand(partialsFolder + '/**/*.html').map(function(partial) {
            return path.relative(indexFolder, partial);
        });
        var html = partials.map(function(partial) {
            // Get the partial content and replace the closing script tags with a placeholder
            var partialContent = grunt.file.read(path.join(indexFolder, partial))
                .replace(/<\/script>/g, '<___/script___>');
            return '<script type="text/ng-template" id="' + partial + '">' + partialContent + '<' + '/script>';
        }).join('');
        // During page initialization replace the placeholder back to the closing script tag
        // @see https://github.com/angular/angular.js/issues/2820
        html += '<script>(' + (function() {
            var scripts = document.getElementsByTagName("script");
            for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].type === 'text/ng-template') {
                    scripts[i].innerHTML = scripts[i].innerHTML.replace(/<___\/script___>/g, '</' + 'script>');
                }
            }
        }) + '())</script>';
        // Inject the html into the ngdoc file
        var patchedIndex = grunt.file.read(indexFile).replace(/<body[^>]*>/i, function(match) {
            return match + html;
        });
        grunt.file.write(indexFile, patchedIndex);
        // Remove the partials
        partials.forEach(function(partial) {
            grunt.file.delete(path.join(indexFolder, partial));
        });
    }

    function exists(filepath) {
        return !!grunt.file.exists(filepath);
    }

    function replacer(key, value) {
        if (key.substr(0, 2) === '__') {
            return undefined;
        }
        return value;
    }

    function now() {
        return new Date().getTime();
    }

    return unittest;
};